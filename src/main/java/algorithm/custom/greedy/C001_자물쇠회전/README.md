## 문제 정보

- **플랫폼**: Custom
- **문제 번호**: C001
- **유형**: Greedy
- **제목**: 자물쇠 회전

## 문제 설명

번호를 돌려서 여는 자물쇠가 있다. i번 자리를 회전하면 i+1번 자리도 함께 +1된다
(9 다음은 0). 마지막 번호는 혼자 돌릴 수 없다.

현재 상태 S를 목표 상태 T로 만드는 최소 회전 횟수를 반환한다.
T를 만들 수 없으면 -1 반환.

## 예시

| S | T | 결과 |
|---|---|------|
| `"11111"` | `"22111"` | 1 |
| `"90909"` | `"01909"` | 1 |
| `"115"` | `"116"` | -1 |
| `"12345"` | `"12345"` | 0 |

## 접근 방식

i번 위치를 r_i번 회전한다고 하면 아래 연립방정식이 성립한다.

```
(S[0] + r0)              mod 10 = T[0]
(S[1] + r0 + r1)         mod 10 = T[1]
...
(S[n-2] + r(n-3) + r(n-2)) mod 10 = T[n-2]
(S[n-1] + r(n-2))        mod 10 = T[n-1]  ← 검증
```

왼쪽부터 r_i를 순서대로 유일하게 결정하고, 마지막 자리 조건이 맞지 않으면 -1.

## 시간복잡도

O(n)

## 핵심 포인트

- 각 r_i는 앞 자리의 결과에 따라 유일하게 결정되므로 BFS 불필요
- 마지막 자리는 조작 불가 → 검증용으로만 사용
- 나머지 연산 시 음수 방지: `((x % 10) + 10) % 10`
